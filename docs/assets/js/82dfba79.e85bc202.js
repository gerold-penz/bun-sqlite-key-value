"use strict";(self.webpackChunkbun_sqlite_key_value_docs=self.webpackChunkbun_sqlite_key_value_docs||[]).push([[24],{772:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"read_write/read_multiple_items","title":"Read Multiple Items","description":"Reads the data from the database and returns items in an array as key-value pairs.","source":"@site/docs/040_read_write/070_read_multiple_items.md","sourceDirName":"040_read_write","slug":"/read_write/read_multiple_items","permalink":"/bun-sqlite-key-value/read_write/read_multiple_items","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":70,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Read Item","permalink":"/bun-sqlite-key-value/read_write/read_item"},"next":{"title":"Read and Write Binary Files (Images)","permalink":"/bun-sqlite-key-value/read_write/read_write_binary_files_iImages"}}');var s=a(4848),r=a(8453);const i={},l="Read Multiple Items",d={},u=[{value:"startsWithOrKeys",id:"startswithorkeys",level:2},{value:"Example",id:"example",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"read-multiple-items",children:"Read Multiple Items"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"getItems(startsWithOrKeys?: string | string[]): {key: string, value: any}[]\n\n<store>.items\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reads the data from the database and returns items in an array as key-value pairs."}),"\n",(0,s.jsx)(n.h2,{id:"startswithorkeys",children:"startsWithOrKeys"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"undefined"}),": Returns all items (key, value) in an array."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"string"}),": Returns all items (key, value) in an array whose keys begin with\nthe passed string.\nIf you plan the names of the keys well, more complex data can be stored.\nIt is advisable to divide keys into ranges using separators.\nFor example ",(0,s.jsx)(n.code,{children:'"language:de"'}),", ",(0,s.jsx)(n.code,{children:'"language:en"'}),", ",(0,s.jsx)(n.code,{children:'"language:it"'}),".\nA search for ",(0,s.jsx)(n.code,{children:'"language:"'})," would return all languages."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"string[]"}),": Array with keys. The returned array is exactly\nthe same size as the passed array.\nItems that are not found are returned as ",(0,s.jsx)(n.code,{children:"undefined"}),".\nOnly exact matches with the keys are returned."]}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { BunSqliteKeyValue } from "bun-sqlite-key-value"\n\nconst store = new BunSqliteKeyValue()\n\nstore.set("language:de", "German")\nstore.set("language:en", "English")\nstore.set("language:it", "Italian")\n\nstore.getItems("language:") // --\x3e [\n//     {key: "language:de", value: "German"},\n//     {key: "language:en", value: "English"},\n//     {key: "language:it", value: "Italian"}\n// ]\n\nstore.items // --\x3e [\n//     {key: "language:de", value: "German"},\n//     {key: "language:en", value: "English"},\n//     {key: "language:it", value: "Italian"}\n// ]\n\n'})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var t=a(6540);const s={},r=t.createContext(s);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);